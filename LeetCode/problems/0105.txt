# mid

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
# time: O(N^2), space: O(1)
class Solution:
    def buildTree(self, po: List[int], io: List[int]) -> TreeNode:
        head = TreeNode()
        id = 0
        def rec(l, r, node):
            nonlocal id
            top = po[id]; id += 1
            node.val = top
            pivot = -1
            for i in range(l, r):
                if io[i] == top:
                    pivot = i
                    break

            if l < pivot:
                left = TreeNode()
                node.left = left
                rec(l, pivot, left)
            else: node.left = None

            if r > pivot+1:
                right = TreeNode()
                node.right = right
                rec(pivot+1, r, right)
            else: node.right = None

        rec(0, len(po), head)
        return head

# time: O(N), space: O(N)
class Solution:
    def buildTree(self, po: List[int], io: List[int]) -> TreeNode:
        mp = {}
        for i, a in enumerate(io):
            mp[a] = i

        head = TreeNode()
        id = 0
        def rec(l, r, node):
            nonlocal id
            top = po[id]; id += 1
            node.val = top
            pivot = mp[node.val]

            if l < pivot:
                left = TreeNode()
                node.left = left
                rec(l, pivot, left)
            else: node.left = None

            if r > pivot+1:
                right = TreeNode()
                node.right = right
                rec(pivot+1, r, right)
            else: node.right = None

        rec(0, len(po), head)
        return head
